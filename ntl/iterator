#pragma once

#include "system"
#include "type_traits"

namespace ntl {

#pragma region iterator_tag

    struct input_iterator_tag {};
    struct output_iterator_tag {};
    struct forward_iterator_tag : public input_iterator_tag {};
    struct bidirectional_iterator_tag : public forward_iterator_tag {};
    struct random_access_iterator_tag : public bidirectional_iterator_tag {};
    struct contiguous_iterator_tag : public random_access_iterator_tag {};

#pragma endregion
#pragma region iterator_traits

    template<typename T>
    struct iterator_traits {
        using difference_type = typename T::difference_type;
        using value_type = typename T::value_type;
        using pointer = typename T::pointer;
        using reference = typename T::reference;
        using iterator_category = typename T::iterator_category;
    };

    template<typename T>
    struct iterator_traits<T*> {
        using difference_type = ptrdiff_t;
        using value_type = T;
        using pointer = T*;
        using reference = T&;
        using iterator_category = random_access_iterator_tag;
    };

#pragma endregion
#pragma region iterator

    template<
        typename Category,
        typename T,
        typename Distance = ntl::ptrdiff_t,
        typename Pointer = T*,
        typename Reference = T&
    >
    class iterator {
    public:
        using value_type = T;
        using difference_type = Distance;
        using pointer = Pointer;
        using reference = Reference;
        using iterator_category = Category;

        iterator(pointer p)
            : p_(p)
        {}

        constexpr bool operator==(iterator const &rhs) {
            return p_ == rhs.p_;
        }

        constexpr bool operator!=(iterator const &rhs) {
            return p_ != rhs.p_;
        }

        constexpr bool operator<(iterator const &rhs) {
            return p_ < rhs.p_;
        }

        constexpr bool operator<=(iterator const &rhs) {
            return p_ <= rhs.p_;
        }

        constexpr bool operator>(iterator const &rhs) {
            return p_ > rhs.p_;
        }

        constexpr bool operator>=(iterator const &rhs) {
            return p_ >= rhs.p_;
        }

    protected:
        pointer p_;
    };

#pragma endregion
#pragma region random_access_iterator

    template<
        typename T,
        typename Distance = ntl::ptrdiff_t,
        typename Pointer = T*,
        typename Reference = T&
    >
    class random_access_iterator
        : public iterator<
            random_access_iterator_tag,
            T,
            Distance,
            Pointer,
            Reference
        >
    {
    public:
        constexpr random_access_iterator() {}
        constexpr random_access_iterator(Pointer x)
            : iterator(x)
        {}

        constexpr random_access_iterator(random_access_iterator const &other)
            : iterator<random_access_iterator_tag, T, Distance, Pointer, Reference>(other.p_)
        {}

        constexpr random_access_iterator& operator=(random_access_iterator const &other) {
            p_ = other.p_;
        }

        constexpr T& operator*() const {
            return *p_;
        }

        constexpr Pointer operator->() const {
            return p_;
        }

        constexpr T& operator[](Distance n) const {
            return p_[n];
        }


        constexpr random_access_iterator& operator++() {
            ++p_;
            return *this;
        }

        constexpr random_access_iterator& operator--() {
            --p_;
            return *this;
        }

        constexpr random_access_iterator operator++(int) {
            auto t = p_;
            ++p_;
            return t;
        }

        constexpr random_access_iterator operator--(int) {
            auto t = p_;
            --p_;
            return t;
        }

        constexpr random_access_iterator operator+(Distance n) const {
            return p_ + n;
        }

        constexpr random_access_iterator operator-(Distance n) const {
            return p_ - n;
        }

        constexpr random_access_iterator& operator+=(Distance n) {
            p_ += n;
            return *this;
        }

        constexpr random_access_iterator& operator-=(Distance n) {
            p_ -= n;
            return *this;
        }
    };

#pragma endregion
#pragma region reverse_iterator

    template<typename I>
    class reverse_iterator {
    public:
        using iterator_type = I;
        using iterator_category = typename ntl::iterator_traits<iterator_type>::iterator_category;
        using value_type = typename ntl::iterator_traits<iterator_type>::value_type;
        using difference_type = typename ntl::iterator_traits<iterator_type>::difference_type;
        using pointer = typename ntl::iterator_traits<iterator_type>::pointer;
        using reference = typename ntl::iterator_traits<iterator_type>::reference;

        constexpr reverse_iterator() {}
        constexpr explicit reverse_iterator(iterator_type x) {
            base_ = x;
        }

        constexpr reverse_iterator(reverse_iterator const &other)
            : base_(other.base_)
        {}

        constexpr reverse_iterator& operator=(reverse_iterator const &other) {
            base_ = other.base_;
        }

        constexpr iterator_type base() const {
            return base_;
        }

        constexpr reference operator*() const {
            return *(base - 1);
        }

        constexpr pointer operator->() const {
            return ntl::addressof(operator*());
        }

        constexpr value_type& operator[](difference_type n) const {
            return base_[-n - 1];
        }


        constexpr reverse_iterator& operator++() {
            --base_;
            return *this;
        }

        constexpr reverse_iterator& operator--() {
            ++base_;
            return *this;
        }

        constexpr reverse_iterator operator++(int) {
            auto t = base_;
            --base_;
            return t;
        }

        constexpr reverse_iterator operator--(int) {
            auto t = base_;
            ++base_;
            return t;
        }

        constexpr reverse_iterator operator+(difference_type n) const {
            return base() - n;
        }

        constexpr reverse_iterator operator-(difference_type n) const {
            return base() + n;
        }

        constexpr reverse_iterator& operator+=(difference_type n) {
            base_ -= n;
            return *this;
        }

        constexpr reverse_iterator& operator-=(difference_type n) {
            base_ += n;
            return *this;
        }

    protected:
        iterator_type base_;
    };


    template<typename I1, typename I2>
    constexpr bool operator==(reverse_iterator<I1> const &lhs, reverse_iterator<I2> const &rhs) {
        return lhs.base() == rhs.base();
    }

    template<typename I1, typename I2>
    constexpr bool operator!=(reverse_iterator<I1> const &lhs, reverse_iterator<I2> const &rhs) {
        return lhs.base() != rhs.base();
    }

    template<typename I1, typename I2>
    constexpr bool operator<(reverse_iterator<I1> const &lhs, reverse_iterator<I2> const &rhs) {
        return lhs.base() < rhs.base();
    }

    template<typename I1, typename I2>
    constexpr bool operator<=(reverse_iterator<I1> const &lhs, reverse_iterator<I2> const &rhs) {
        return lhs.base() <= rhs.base();
    }

    template<typename I1, typename I2>
    constexpr bool operator>(reverse_iterator<I1> const &lhs, reverse_iterator<I2> const &rhs) {
        return lhs.base() > rhs.base();
    }

    template<typename I1, typename I2>
    constexpr bool operator>=(reverse_iterator<I1> const &lhs, reverse_iterator<I2> const &rhs) {
        return lhs.base() >= rhs.base();
    }

#pragma endregion
#pragma region operations

    template<typename II>
    constexpr typename iterator_traits<II>::difference_type distance(II first, II last) {
        if constexpr (is_same_v<random_access_iterator_tag, typename iterator_traits<II>::iterator_category>) {
            return last - first;
        } else {
            static_assert(
                is_same_v<random_access_iterator_tag, typename iterator_traits<II>::iterator_category>,
                "TODO: support more types in ntl::distance"
            );
        }
    }

#pragma endregion

}
