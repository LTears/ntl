#pragma once

#include "system"

namespace ntl {

    template<typename T>
    class allocator final {
    public:
        using value_type = T;
        using size_type = ntl::size_t;
        using difference_type = ntl::ptrdiff_t;

        constexpr explicit allocator(POOL_TYPE pool_type = NonPagedPoolNx, ULONG tag = NTL_TAG)
            : pool_type_(pool_type)
            , tag_(tag)
        {}

        constexpr allocator(allocator const &other)
            : pool_type_(pool_type)
            , tag_(tag)
        {}

        template<typename U>
        constexpr allocator(allocator<U> const &other)
            : pool_type_(pool_type)
            , tag_(tag)
        {}

        ~allocator() {}

        T* allocate(size_type n) {
#if !DEBUG_IN_USER_MODE
            T *result = ExAllocatePoolWithTag(pool_type_, sizeof(T) * n, tag_);
            if (!result) {
                ExRaiseStatus(STATUS_FATAL_MEMORY_EXHAUSTION);
            }
#else
            T *result = calloc(n, sizeof(T));
            if (!result) {
                SetLastError(ERROR_OUTOFMEMORY);
            }
#endif
            return result;
        }

        void deallocate(T *p, size_type n) {
#if !DEBUG_IN_USER_MODE
            ExFreePoolWithTag(object, tag_);
#else
            free(p);
#endif
        }

    private:
        POOL_TYPE pool_type_;
        ULONG tag_;
    };

    template<typename T1, typename T2>
    bool operator==(allocator<T1> const &lhs, allocator<T2> const &rhs) {
        return false;
    }

    template<typename T>
    bool operator==(allocator<T> const &lhs, allocator<T> const &rhs) {
        return lhs.pool_type_ == rhs.pool_type_ && lhs.tag_ == rhs.tag_;
    }

    template<typename T1, typename T2>
    bool operator!=(allocator<T1> const &lhs, allocator<T2> const &rhs) {
        return true;
    }

    template<typename T>
    bool operator!=(allocator<T> const &lhs, allocator<T> const &rhs) {
        return lhs.pool_type_ != rhs.pool_type_ || lhs.tag_ != rhs.tag_;
    }
}
