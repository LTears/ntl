#pragma once

#include "system"

namespace ntl {

    template<typename T>
    class allocator final {
    public:
        using value_type = T;
        using size_type = ntl::size_t;
        using difference_type = ntl::ptrdiff_t;

        constexpr explicit allocator(ULONG tag = NTL_TAG)
            : tag_(tag)
        {}

        constexpr allocator(allocator const &other)
            : tag_(other.tag_)
        {}

        template<typename U>
        constexpr allocator(allocator<U> const &other)
            : tag_(other.tag_)
        {}

        ~allocator() {}

        T* allocate(size_type n) {
            T *result = ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(T) * n, tag_);
            if (!result) {
                ExRaiseStatus(STATUS_FATAL_MEMORY_EXHAUSTION);
            }
            return result;
        }

        void deallocate(T *p, size_type n) {
            ExFreePoolWithTag(object, tag_);
        }

    private:
        ULONG tag_;
    };

    template<typename T1, typename T2>
    bool operator==(allocator<T1> const &lhs, allocator<T2> const &rhs) {
        return false;
    }

    template<typename T>
    bool operator==(allocator<T> const &lhs, allocator<T> const &rhs) {
        return lhs.tag_ == rhs.tag_;
    }

    template<typename T1, typename T2>
    bool operator!=(allocator<T1> const &lhs, allocator<T2> const &rhs) {
        return true;
    }

    template<typename T>
    bool operator!=(allocator<T> const &lhs, allocator<T> const &rhs) {
        return lhs.tag_ != rhs.tag_;
    }
}
