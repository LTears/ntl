#pragma once

#include "system"
#include "ntl"
#include "algorithm"
#include "allocator"
#include "utility"
#include "iterator"

namespace ntl {

    template<typename T, typename Allocator = ntl::allocator<T>>
    class vector final {
    public:
        using value_type = T;
        using allocator_type = Allocator;
        using size_type = ntl::size_t;
        using difference_type = ntl::ptrdiff_t;
        using reference = value_type&;
        using const_reference = value_type const&;
        using pointer = T*;
        using const_pointer = T const*;
        class iterator : public ntl::random_access_iterator<value_type> {};
        class const_iterator : public ntl::random_access_iterator<value_type const> {};
        using reverse_iterator = ntl::reverse_iterator<iterator>;
        using const_reverse_iterator = ntl::reverse_iterator<const_iterator>;

        vector()
            : begin_(nullptr)
            , end_(nullptr)
            , capacity_(0)
            , allocator_()
        {}

        explicit vector(allocator_type const &allocator)
            : begin_(nullptr)
            , end_(nullptr)
            , capacity_(0)
            , allocator_(allocator)
        {}

        vector(size_type count, value_type const &value, allocator_type const &allocator = allocator_type())
            : vector(allocator)
        {
            capacity_ = count;
            begin_ = allocator_.allocate(capacity_);
            end_ = begin_ + capacity_;
            for (size_t i = 0; i != capacity_; i++) {
                push_back(value);
            }
        }

        explicit vector(size_type count, allocator_type const &allocator = allocator_type())
            : vector(allocator)
        {
            capacity_ = count;
            begin_ = allocator_.allocate(capacity_);
            end_ = begin_ + capacity_;
            for (size_t i = 0; i != capacity_; i++) {
                push_back(value_type());
            }
        }

        template<typename II>
        vector(II first, II last, allocator_type const &allocator = allocator_type())
            : vector(allocator)
        {
            capacity_ = ntl::distance(first, last);
            begin_ = allocator_.allocate(capacity_);
            end_ = begin_ + capacity_;
            for (; first != last; ++first) {
                push_back(*first);
            }
        }

        vector(vector const &other) {
            capacity_ = other.size();
            begin_ = allocator_.allocate(capacity_);
            end_ = begin_ + capacity_;
            for (auto const &e : other) {
                push_back(e);
            }
        }

        vector(vector const &other, allocator_type const &allocator)
            : vector(allocator)
        {
            capacity_ = other.size();
            begin_ = allocator_.allocate(capacity_);
            end_ = begin_ + capacity_;
            for (auto const &e : other) {
                push_back(e);
            }
        }

        vector(vector &&other)
            : begin_(other.begin_)
            , end_(other.end_)
            , capacity_(other.capacity_)
            , allocator_(other.allocator_)
        {
            other.begin_ = nullptr;
            other.end_ = nullptr;
            other.capacity_ = 0;
        }

        vector(vector &&other, allocator_type const &allocator)
            : begin_(other.begin_)
            , end_(other.end_)
            , capacity_(other.capacity_)
            , allocator_(allocator)
        {
            other.begin_ = nullptr;
            other.end_ = nullptr;
            other.capacity_ = 0;
        }

        ~vector() {
            clear();
        }

        vector& operator=(vector const &other) {
            clear();
            reserve(other.size());
            for (auto const &e : other) {
                push_back(e);
            }
        }

        vector& operator=(vector &&other) {
            clear();
            swap(other);
        }

        void assign(size_type count, value_type const &value) {
            clear();
            capacity_ = count;
            begin_ = allocator_.allocate(capacity_);
            end_ = begin_ + capacity_;
            for (auto p = begin_; p != end_; p++) {
                new (p) value_type(value);
            }
        }

        template<typename II>
        void assign(II first, II last) {
            clear();
            capacity_ = ntl::distance(first, last);
            begin_ = allocator_.allocate(capacity_);
            end_ = begin_ + capacity_;
            for (auto p = begin_; p != end_; p++, ++first) {
                new (p) value_type(*first);
            }
        }

        reference at(size_type position) {
            if (position >= size()) {
                ExRaiseStatus(STATUS_ARRAY_BOUNDS_EXCEEDED);
            }
            return begin_[position];
        }

        const_reference at(size_type position) const {
            if (position >= size()) {
                ExRaiseStatus(STATUS_ARRAY_BOUNDS_EXCEEDED);
            }
            return begin_[position];
        }

        reference operator[](size_type position) {
            return begin_[position];
        }

        const_reference operator[](size_type position) const {
            return begin_[position];
        }

        reference front() {
            return *begin_;
        }

        const_reference front() const {
            return *begin_;
        }

        reference back() {
            return *(end_ - 1);
        }

        const_reference back() const {
            return *(end_ - 1);
        }

        pointer data() {
            return begin_;
        }

        const_pointer data() const {
            return begin_;
        }

        iterator begin() {
            return begin_;
        }

        const_iterator begin() const {
            return begin_;
        }

        const_iterator cbegin() const {
            return begin_;
        }

        iterator end() {
            return end_;
        }

        const_iterator end() const {
            return end_;
        }

        const_iterator cend() const {
            return end_;
        }

        reverse_iterator rbegin() {
            return end_ - 1;
        }

        const_reverse_iterator rbegin() const {
            return end_ - 1;
        }

        const_reverse_iterator crbegin() const {
            return end_ - 1;
        }

        reverse_iterator rend() {
            return begin_ - 1;
        }

        const_reverse_iterator rend() const {
            return begin_ - 1;
        }

        const_reverse_iterator crend() const {
            return begin_ - 1;
        }

        bool empty() const {
            return begin() == end();
        }

        size_type size() const {
            return ntl::distance(begin(), end());
        }

        void reserve(size_type new_capacity) {
            if (new_capacity <= capacity_) {
                return;
            }
            vector new_vector(allocator_);
            new_vector.capacity_ = new_capacity;
            new_vector.begin_ = allocator_.allocate(new_capacity);
            new_vector.end_ = new_vector.begin_ + new_capacity;
            for (auto &&e : *this) {
                new_vector.push_back(ntl::move(e));
            }
            swap(new_vector);
        }

        size_type capacity() const {
            return capacity_;
        }

        void shrink_to_fit() {
            if (size() == capacity_) {
                return;
            }
            vector new_vector(allocator_);
            new_vector.reserve(size());
            for (auto &&e : *this) {
                new_vector.emplace_back(ntl::move(e));
            }
            swap(new_vector);
        }

        void clear() {
            for (auto &e : *this)
                e.~value_type();
            allocator_.deallocate(begin_, capacity_);
            begin_ = nullptr;
            end_ = nullptr;
            capacity_ = 0;
        }

        iterator insert(const_iterator position, value_type const &value) {
            // TODO
        }

        iterator insert(const_iterator position, value_type &&value) {
            // TODO
        }

        iterator insert(const_iterator position, size_type count, value_type const &value) {
            // TODO
        }

        template<typename II>
        iterator insert(const_iterator position, II first, II last) {
            // TODO
        }

        template<typename ...Args>
        iterator emplace(const_iterator position, Args &&...args) {
            // TODO
        }

        iterator erase(const_iterator position) {
            // TODO
        }

        iterator erase(const_iterator first, const_iterator last) {
            // TODO
        }

        void push_back(value_type &&value) {
            if (size() >= capacity()) {
                size_type new_size = capacity() * 2;
                if (!new_size) {
                    new_size++;
                }
                reserve(new_size);
            }
            new (end_++) value_type(ntl::move(value));
        }

        template<typename ...Args>
        reference emplace_back(Args &&...args) {
            if (size() >= capacity()) {
                size_type new_size = capacity() * 2;
                if (!new_size) {
                    new_size++;
                }
                reserve(new_size);
            }
            new (end_) value_type(ntl::forward<value_type>(args));
            return *(end_++);
        }

        void pop_back() {
            if (!empty())
                end_--;
        }

        void resize(size_type count) {
            resize(count, value_type());
        }

        void resize(size_type count, value_type const &value) {
            if (count <= size()) {
                end_ = begin_ + count;
            } else {
                vector new_vector(allocator_);
                new_vector.reserve(count);
                for (auto &&e : *this) {
                    new_vector.push_back(ntl::move(e));
                }
                for (size_type i = size(); i != count; i++) {
                    new_vector.push_back(value);
                }
                swap(new_vector);
            }
        }

        void swap(vector &other) {
            ntl::swap(begin_, other.begin_);
            ntl::swap(end_, other.end_);
            ntl::swap(capacity_, other.capacity_);
            ntl::swap(allocator_, other.allocator_);
        }

    private:
        pointer begin_, end_;
        size_type capacity_;
        allocator_type allocator_;
    };

    template<typename T, typename Allocator>
    bool operator==(vector<T, Allocator> const &lhs, vector<T, Allocator> const &rhs) {
        if (lhs.size() != rhs.size()) {
            return false;
        }
        return equals(lhs.begin(), lhs.end(), rhs.begin());
    }

    template<typename T, typename Allocator>
    bool operator!=(vector<T, Allocator> const &lhs, vector<T, Allocator> const &rhs) {
        if (lhs.size() != rhs.size()) {
            return true;
        }
        return !equals(lhs.begin(), lhs.end(), rhs.begin());
    }

    template<typename T, typename Allocator>
    bool operator<(vector<T, Allocator> const &lhs, vector<T, Allocator> const &rhs) {
        return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
    }

    template<typename T, typename Allocator>
    bool operator<=(vector<T, Allocator> const &lhs, vector<T, Allocator> const &rhs) {
        return !(lhs > rhs);
    }

    template<typename T, typename Allocator>
    bool operator>(vector<T, Allocator> const &lhs, vector<T, Allocator> const &rhs) {
        return lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(),
            [](vector<T, Allocator>::const_iterator a, vector<T, Allocator>::const_iterator b) {
                if (*a > *b)
                    return true;
                if (*b > *a)
                    return false;
            }
        );
    }

    template<typename T, typename Allocator>
    bool operator>=(vector<T, Allocator> const &lhs, vector<T, Allocator> const &rhs) {
        return !(lhs < rhs);
    }

}
